---
titie: "Objects: the basics"
---

## Objects

`Object` の基本的構成要素を学ぶ。

* キーのほうが動的に定義される仕組みがある。これを computed property という。
  この応用が後ほどたくさん出てくる。

  ```javascript
  let fruit = prompt("Which fruit to buy?", "apple");
  let bag = {
    [fruit]: 5, // e.g. bag.apple == 5
  };
  ```

* 属性値の略記法が存在することを確認。
* 便宜上 `__proto__` をここで紹介。
* 属性キーの存在テストに演算子 `in` を用いることができる。
* オブジェクトのキーを `for ... in` 文で順次アクセスできる。

## Object references and copying

* `Object.assign()` の意味はメンバーごとの代入が基本。浅いコピーを行う。
* `const` オブジェクトの属性の値を（参照でなくても）単純な代入式で変更することができる。

## Garbage collection

* 到達可能性の概念
* JavaScript でオブジェクトに対するゴミ収集が発生するのは、
  そのオブジェクトが到達不能である必要がある。
  * 循環参照の例アリ。
* オブジェクト参照関係が構成するグラフの連結成分がまるごと到達不能になると、
  その連結成分にあるオブジェクトすべてがゴミ収集の対象となると考えていい。
* ゴミ収集の最適化について

## Object methods, "this"

二点だけ押さえる。

* `this` の意味が他言語とかなり異なる。
* 矢印関数に `this` はない。

## Constructor, operator "new"

* まだ `class` 文を知らない状態でコンストラクターを定義する。
  * 構文上は通常の関数定義とまったく変わらない。
  * 関数本体に `this` が現れる。
  * 呼び出し時に `new` を伴うと、戻り値、すなわち `this` に相当するオブジェクトを
    暗黙に生成するので、この関数をコンストラクターと呼ぶのがふさわしい。
* `new.target` は知らないままでも問題ないだろう。

現代的な `class` 構文はもっと後になってやるのだが、この言語仕様がその根底にある。

## Optional chaining '?.'

既存の `?` 系演算子に比べるとそれほど便利ではないようだ。

## Symbol type

`Object` のキーの型は `string` または `Symbol` に限られる。ここでは後者が説明される。

* `Symbol` は一意的な識別子を実現するのに用意された組み込み型だ。
* `Symbol` オブジェクトは他の型のオブジェクトとは異なり、文字列への自動変換がなされない。
* `Symbol` でオブジェクトのキーを定義すると、その属性は「隠される」。
  例えば `for ... loop` 文でそのような属性にはアクセスされない。
* オブジェクトリテラル形式で定義する際には角括弧を要する。
* `Object.assign()` は `Symbol` による属性を考慮する。
* `Symbol.for()` で、定義済みのシンボルを検索する。逆に
  `Symbol.keyFor()` は既存のシンボルから名前を得る。
* システムシンボル、言語が規定するシンボルが大量に定義されている。

シンボルの考え方がこのあとたくさん出てくる。

## Object to primitive conversion

それにしても、このチュートリアルはオブジェクトの変換についての記述が細かくて信頼できる。

前にも出てきたが、組み込み型への変換が必要なときにオブジェクトからの自動変換が引き起こされる。

* オブジェクトに `[Symbol.toPrimitive]()` メソッドがあれば、それが優先的に採用される。
* あるいはオブジェクトの `toString()`, `valueOf()` が用意されていれば、それが採用される。
  文字列が必要な場合は前者が、数やデフォルトが必要な場合は後者がそれぞれ優先され、前者がその次に採用される。
