---
title: Prototypes, inheritance
---

## Prototypal inheritance

* まずは `__proto__` の説明。
* プロトタイプはプロパティーの読み取りにしか使わないものだ。
  最初の例でフラグを書き換えてデバッグして確認済み。
* その次の `user` と `admin` の例で再確認。
  メソッド呼び出しに関する `this` の決定仕様により、状態は共有されない。
* 単純なキー・値列挙機能のほとんどは基底プロパティーを無視する。
* C++ が第一プログラミング言語の者からすると、基底オブジェクト側メソッド内で
  `this` を経由する属性への代入は注意。呼び出し側のオブジェクトの属性として作用する。
* ハムスター問題は微妙かもしれない。解 2 だと継承の利点がほぼない。
  コメント欄もハムスター問題への言及が多い。
* コメント欄にある「フランケンスクリプト」という言葉が気に入る。

## F.prototype

* 関数の属性 `prototype` にオブジェクトを割り当てて `new` を使って呼び出してもよい。
* オブジェクト属性 `constructor` というのが（普通は）そのオブジェクトを生成した関数だ。

## Native prototypes

* これらを上書きすることができる。しかしグローバルなものなので、それは悪い考えのはずだ。
* やはり多重継承は不能のようだ。
* 演習問題 2 は最初は `(a, b)` で試す。それから一般の引数リストを対応する。
  そして、解答にあるオブジェクトメソッドに作用させる方法にクセがあることに注意。

## Prototype methods, objects without __proto__

* `__proto__` は時代遅れ。当世風の記法がある。
* 序盤のコード例は数章前のそれを書き改めたものだ。
* `Object.create(null)` は `{}` とは違う。
* 演習問題 1 は `Object.defineProperty()` のほうがコード埋め問題の解としてはいいと思う。
  後付けの場合 `Object.setPropertyOf()` は `enumerable` を指定できないからダメか？
