---
title: 339 日目（晴れ）今月もなんとかやり過ごした
---

[ウルファールのサンプルゲーム with DTC][bshf21b] でアイテムを集めておく。風神の盾三つ。
アスクレピオスの杖が 17 個になってどうしようもない。

ダウンロードしてあるいつものネコビデオをチェックして寝る。

7:05 起床。今日も朝から眠いパターンか。納豆とロールパンを食して出勤。用事があるので PC なし。

7:45 管理人室到着。資源ゴミの仕込みをやっていなかった。搬出しながら片付けるしかない。
空き缶を表に出すと、何者かがアルミ缶を選り分けて持っていってくれた。

10:00 終了。撤収。イトーヨーカドー曳舟店で今月最後の体温チェック。
ハガキに記入して、業務報告書と同封する。京島一丁目郵便局のポストに投函。

10:20 ひきふね図書館。朝刊（産経）、ホビージャパンの読者イラストをチェック。
『謎解きの英文法 副詞と数量詞』の残りを読む。全称数量詞と存在数量詞か。文法というより論理だな。

またぞろイトーヨーカドーに戻り、トイレを借りる。それから曳舟の部屋に戻る。11:30 過ぎ辺り。
PC の電源を入れて時間調整のための作業。昨日の一件でびっくりしたのでハードディスクの空きを作る。

* Cygwin: コマンドライン環境を WSL に完全移行。手動でアンインストール予定。`/tmp` に何か残っているはず。
* Cygwin Bash Prompt Here: Cygwin を処部するので必然的にこれも不要となる。
* DeepL: ローカルで持つ意味がないので処分。アンインストーラーがレジストリーを消さない？
* Git (for Windows): WSL のものを用いる。
* Groove ミュージック: VLC ユーザーにつき。
* Microsoft ニュース: 使わないので処分。
* Miniconda3: WSL のものを用いる。
* MSYS2: コマンドライン環境を WSL に完全移行。
* Node.js: WSL のものを用いる。
* Pandoc: WSL のものを用いる。
* Ruby26: WSL のもっとよいバージョンを用いるので処分。アンインストーラーがない？
* Skype: 使わないので処分。
* Spotify: 使わないので処分。

以上のプログラム群をおやつを食いながらハードディスクから削る。13:00 終了。
福祉事務所に行くまで時間ができたので、麻雀の練習で暇つぶしして居眠り。

15:30 起き上がる。必要書類を持って外出。いつもと若干違う経路で区役所へ向かう。
日当たりがきつくて水戸街道は歩けない。高速道路が高架になって日影があるいる隅田川沿いを歩く。

16:00 区役所に到着。一階の奥から入庁してみる。ちばてつや先生の絵を折り紙アート化した作品が新作になっている。
これが迫力があって素晴らしい。矢吹丈の表情は一般人が折り紙を重ね合わせて構成したのがむしろ味になっている。

福祉事務所に移動。担当 I 氏と久々の面会。相変わらずお元気そうで何より。
用を済ませたら退庁。先週のように徒歩でスカイツリータウンに移動する。
東武の駅側から商店街に入ろうとすると、ガード下の通路が微妙にズレていることに気づく。工事中。

三省堂書店で文藝春秋から出ている将棋ムックをチェック。

バス停に移動して少し待ってバスに乗る。錦糸公園前まで移動。

17:00 タイトー F ステーションオリナス錦糸町店。

MJ プロ卓東風戦 5 クレ。今月はマイナ 1000 点で終わる。点棒換算だといくらだ。怖くて計算したくない。
最終日くらいは常識的な成績で終わりたい。

```text
【SCORE】
合計SCORE:+30.3

【最終段位】
四人打ち段位:神龍 幻球:9

【3/31の最新8試合の履歴】

1st|*----*--
2nd|-*-----*
3rd|---*----
4th|--*-*-*-
old         new

【順位】
1位回数:3(33.33%)
2位回数:2(22.22%)
3位回数:1(11.11%)
4位回数:3(33.33%)
平均順位:2.44

プレイ局数:44局

【打ち筋】
アガリ率:15.91%(7/44)
平均アガリ翻:4.71翻
平均アガリ巡目:11.14巡
振込み率:13.64%(6/44)

【3/31の最高役】
・倍満
・跳満
・跳満
```

印象に残ったのはお座りワンゲーム目の東一局。
上家のトイトイ跳満に放銃するが（上級者らしく捨牌がよく出来ていた）、次局で気合でテンパイした三色倍満に気合で放銃させる。
こんな苦しい牌でアガれるとは思っていないから、店内でガッツポーズを思わずとる。

![デバサイ]({{ "/assets/images/20210331-mj.png" | relative_url }})

早めにゲームを終えて店内を探索。隣の FOOTISTA の無料説明を閲覧。これがよくできている。
0 クレで制限時間 5 分でコンパネからスライドショーをコマ送りで流したり、動画を再生したり。さすがセガ。

19:45 カスミオリナス錦糸町店。438 円。

* オクラ茄子丼
* ハムカツ
* ブラックチョコ
* ライス

20:10 ビッグエー墨田業平店。247 円。

* 絹豆腐
* 大きなおむすび鮭
* 大きなツナオニオンパン
* コッペパンジャム＆マーガリン

20:20 曳舟の部屋に戻る。PC をいったん起動して、昨日失敗した低速テザリングによる自動ダウンロードコマンドを実行。
そのまま入浴。そのまえに便器が汚れているので掃除する。目が疲れて汚れに気づかなかったか。

20:45 風呂から出る。豆腐を食いながら PC に戻る。ダウンロードがやはり遅い。まだ 5 ファイルしかダウンロードしていない。
ところが、この日記や帳簿を付けてからまたコンソールを確認すると、急にペースが上がっている。
そういえば、各ダウンロードの経過時間は数秒なのに、実際の時間はそれより全然長いのはおかしい。
たぶん `wget` がダウンロード済みのファイルを重複処理しないための特別な振る舞いに時間を費やしているのだろう。

このまま晩飯を食いながら麻雀の練習に入る。

テザリングを有効にしたままインターネット閲覧の時間だが、携帯電話から写真を転送したいので一時的にファイル転送モードに切り替える。
矢吹丈の写真を Twitter に投稿したいが、運悪く Twitter のエラー画面が出るので諦める。

22:15 XPath の練習でもするか。

24:00 ちょうど XPath の入門記事を読了。

## XPath Note

XPath 1.0 というのをまずは習得したい。

[List of XPaths [XPath 1.0 Tutorial @ Zvon.org]](http://www.zvon.org/comp/r/tut-XPath_1.html#intro) を最初の教科書にする。
リンク先の記事の見出しをクリックするとより詳細なコード例が現れる。

### XPath as filesystem addressing

スラッシュ一つから始まる UNIX のファイルシステムの絶対パス表記のような XPath 式は、
ドキュメントルートからのパスを表現する。

```xpath
/AAA
/AAA/CCC
/AAA/DDD/BBB
```

### Start with `//`

スラッシュ二つ `//` から始まる XPath 式は、後続する条件を満たし、かつドキュメント内にある要素全てを表す。

```xpath
//BBB
//DDD/BBB
```

### All elements ``*``

星印 ``*`` はあらゆる要素にマッチする。

```xpath
/AAA/CCC/DDD/*
/*/*/*/BBB
//*
```

* 二番目の式はルートから数えて 4 階層目にある要素 `BBB` すべてを選択する。
* 最後の式は「文書中にあるすべての要素」を表現するふつうの XPath 式だ。

### Further conditions inside `[]`

角括弧 ``[]`` を使って要素をさらに限定するための何かを指定する。

1 始まりの番号を指定すると、選択集合にある要素の位置を指定することになる。
関数 `last()` を指定すると、選択集合の最後の要素を指定することになる。

```xpath
/AAA/BBB[1]
/AAA/BBB[last()]
```

なぜ 0 ではなく 1 始まりなのかはあとでわかるように記す。

### Attributes `@`

属性を指定するには `@` 接頭辞を用いる。

```xpath
//@id
//BBB[@id]
//BBB[@name]
//BBB[@*]
//BBB[not(@*)]
```

今までは XML の要素を選択する例だったが、この例では属性を選択することに注意。
XML では要素も属性もノードと呼ばれる抽象概念の特殊概念として捉えること。

* 三番目の式と最後の式はそれぞれ「（何でもいいから）属性を有する要素」「属性を（何も）有しない要素」を表す。

### Attribute values

属性の値を選択の判定方法として用いることができる。

```xpath
//BBB[@id='b1']
//BBB[@name='bbb']
//BBB[normalize-space(@name)='bbb']
```

* 最初の XPath 式は「属性 `id` の値が `b1` であるような要素 `BBB` すべて」を表現する。
* 関数 `normalize-space()` は文字列の前後から空白を除去し、なおかつ連続する空白文字の列を単一の空白文字に置き換える。
  ここでは `@name` に、つまり属性 `name` の値に作用する。

### Nodes counting

関数 `count()` は選択要素の個数を返す。

```xpath
//*[count(BBB)=2]
//*[count(*)=2]
//*[count(*)=3]
```

* 最初の式は「子要素 `BBB` がちょうど 2 個あるような要素すべて」か。
* 残りの式も ``*`` が二回ずつでてきて意味をつかめない。

### Playing with names of selected elements

```text
//*[name()='BBB']
//*[starts-with(name(),'B')]
//*[contains(name(),'C')]
```

* 関数 `name()` は要素の名前を返す。
* 関数 `starts-with()` は引数を二つとる。最初の引数の文字列が次の引数の文字列で始まるような文字列であれば真を返す。
* 関数 `contains()` は最初の引数の文字列が次の引数の文字列を部分に含むならば真を返す。
* 角括弧は Boolean を受けるという性質があることを意識すること。
* 最初の式はもっと自然な表現がある。

### Length of string

関数 `string-length()` は文字列を構成する文字の個数を返す。

```xpath
//*[string-length(name()) = 3]
//*[string-length(name()) < 3]
//*[string-length(name()) > 3]
```

### Combining XPaths with `|`

パイプ記号 `|` を使って複数のパスを結合することができる。
というよりは、複数の XPath 式の和集合を得ると考えられる。

```xpath
//CCC | //BBB
/AAA/EEE | //BBB
/AAA/EEE | //DDD/CCC | /AAA | //BBB
```

この例だと最初のものは「文書内の要素 `CCC` すべてまたは文書内の要素 `BBB` すべて」を意味する。

### Child axis

ここから axis の解説が続く。日本語の文書では axis をまんま「軸」を訳すようだ。

`child::` はコンテキストノードの子すべてを含む。

ただし、`child::` は既定の axis なので省略することができる。
例の最初と二番目の XPath 式は同じであり、「ルートの子要素である `AAA` すべて」の意味となる。
また、三番目と四番目と五番目が同じものを表現する。

```xpath
/AAA
/child::AAA
/AAA/BBB
/child::AAA/child::BBB
/child::AAA/BBB
```

どうやら axis の名称はすべて英語単数形らしいが、実際に表現されるものが複数あることは普通だ。

### Descendant axis

`descentant::` はコンテキストノードの子、あるいはさらにその子、等々、を含む。
したがって `descendant::` は属性や名前空間を含むことはない。

```xpath
/descendant::*
/AAA/BBB/descendant::*
//CCC/descendant::*
//CCC/descendant::DDD
```

* 最初の式はルートの子孫要素すべてを、したがってすべての要素を意味する。
* 二番目は `/AAA/BBB` の子孫要素のすべてを表す。書き忘れたがコンテキストノード自身は式の表現するものに含まれない。
* 三番目は「文書内の要素 `CCC` それぞれに対する子孫ノードすべて」を表す。
* 四番目は「文書内の要素 `CCC` それぞれに対する子孫ノードであるような要素 `DDD` すべて」を表す。
  「すべて」が二度出ることに注意する。

### Parent axis

`parent::` はコンテキストノードの親ノードを表す。ない場合はどうなるか。

```xpath
//DDD/parent::*
```

### Ancestor axis

`ancestor::` はコンテキストノードの親、あるいはその親、等々、を表す。
コンテキストノードがルートでない限りは常にルートノードを含む。

```xpath
/AAA/BBB/DDD/CCC/EEE/ancestor::*
//FFF/ancestor::*
```

実用上は最初の例のようなものは見かけないだろう。

### Following-sibling axis

`following-sibling::` はコンテキストノードの「後続（文書のより後方にある）の兄弟ノードすべて」を含む。

```xpath
/AAA/BBB/following-sibling::*
//CCC/following-sibling::*
```

### Preceding-sibling axis

`preceding-sibling::` はコンテキストノードの「先行（文書のより前方にある）兄弟ノードすべて」を含む。

The preceding-sibling axis contains all the preceding siblings of the context node

```xpath
/AAA/XXX/preceding-sibling::*
//CCC/preceding-sibling::*
```

### Following axis

`following::` はコンテキストノードの「文書内にあるより後方のノードすべて」を含む。
ただしコンテキストノード自身の子孫ノード、属性ノード、名前空間ノードを含まない。

```xpath
/AAA/XXX/following::*
//ZZZ/following::*
```

### Preceding axis

`preceding::` はコンテキストノードの「文書内にあるより前方のノードすべて」を含む。
ただしコンテキストノード自身の祖先ノード、属性ノード、名前空間ノードを含まない。

```xpath
/AAA/XXX/preceding::*
//GGG/preceding::*
```

### Descendant-or-self axis

`descendant-or-self::` は `descendant::` およびコンテキストノード自身を含む。

```xpath
/AAA/XXX/descendant-or-self::*
//CCC/descendant-or-self::*
```

### Ancestor-or-self axis

`ancestor-or-self::` は `ancestor::` およびコンテキストノード自身を含む。それゆえ常にルートノードを含む。

```xpath
/AAA/XXX/DDD/EEE/ancestor-or-self::*
//GGG/ancestor-or-self::*
```

### Orthogonal axes

`ancestor::`, `descendant::`, `following::`, `preceding::`, `self::` は属性と名前空間を無視すれば文書中のノード全体を類別する。
この事実は XPath の設計の基本のはずなので、よく憶えておくことだ。

```xpath
//GGG/ancestor::*
//GGG/descendant::*
//GGG/following::*
//GGG/preceding::*
//GGG/self::*
//GGG/ancestor::* | //GGG/descendant::* | //GGG/following::* | //GGG/preceding::* | //GGG/self::*
```

### Numeric operations

私が使うことはなさそうだが、XPath は簡単な算術演算をサポートしている。

```xpath
//BBB[position() mod 2 = 0]
//BBB[position() = floor(last() div 2 + 0.5) or position() = ceiling(last() div 2 + 0.5)]
//CCC[position() = floor(last() div 2 + 0.5) or position() = ceiling(last() div 2 + 0.5)]
```

むしろ、より基本的な関数 `position()` や論理演算子 `or` に注目したい。

[bshf21b]: https://wodifes.net/game/show/446
