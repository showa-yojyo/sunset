---
title: 225 日目（晴れ）欲がだんだん出てくる
---

ギターメドレーをキリのいいところで打ち切って寝たい。ああ、ゼルダの伝説のエンディングか。……いいね。

8:25 起床。トイレに行って寝床に戻って 20 分ほど毛布をかぶって座禅を組んで体の冷えを取り去る。
それから朝食をとり、PC をカバンに入れて抱えて外出だ。明治通りに直行してバスに乗る。この時間帯は
10 分おきに運行しているようだ。ラッシュ時間帯さえ避ければ何とか乗りこなせる。

9:55 ゆいの森あらかわ到着。四階がガラ空きだ。

* [CPU-Z](https://www.cpuid.com/softwares/cpu-z.html)
* [How to show the pipe "&#x7c;" symbol in Markdown table? - Stack Overflow](https://stackoverflow.com/questions/23723396/how-to-show-the-pipe-symbol-in-markdown-table)
* [sed - Print lines of a file between two matching patterns - Unix &amp; Linux Stack Exchange](https://unix.stackexchange.com/questions/264962/print-lines-of-a-file-between-two-matching-patterns)
* 『C++ のエッセンス』第 13 章の読書ノート。図書館で済ませるつもりか。

朝刊（朝日）を読んで 13:30 退館。妙に遅くなった。バス停に移動したら即亀戸駅行きが到着してくれてラッキー。

13:25 曳舟の部屋に戻る。おやつ休憩。`.bash_functions` のクリナップ。また眠くなる。

15:10 起きて WSL いじり。`wslvar` のコマンドラインオプションの半分しか使えない？

16:00 外出。スカイツリータウンでトイレを使わせてもらってからバス停に移動。
錦糸町駅行きに乗って太平四丁目で降りる。オリナスまで歩く。

タイトー F ステーションオリナス錦糸町店で 4 クレ遊ぶ。
ビートマニアの STEP UP でレベル 12 の Colors が意外に善戦できることがわかった。
次にプレイするとクリアランプが点灯させられるかもしれない。

MJ プロ卓東風戦。ひじょうに好調。

```text
【SCORE】
合計SCORE:+139.5

【最終段位】
四人打ち段位:雷神 幻球:11

【12/7の最新8試合の履歴】
1st|*-*---*-
2nd|----**--
3rd|-*-*---*
4th|--------
old         new

【順位】
1位回数:3(37.50%)
2位回数:2(25.00%)
3位回数:3(37.50%)
4位回数:0(0.00%)
平均順位:2.00

プレイ局数:35局

【打ち筋】
アガリ率:22.86%(8/35)
平均アガリ翻:3.25翻
平均アガリ巡目:10.13巡
振込み率:2.86%(1/35)

【12/7の最高役】
・跳満
・跳満
```

19:05 カスミオリナス錦糸町店。327 円。クーポン使用。

* 野菜ジュース (900)
* 生姜焼き丼

19:20 ビッグエー墨田業平店。420 円。

* ベビーチーズ Mozzarella (4)
* レーズンロール (4)
* キャベツメンチカツドッグ
* パンケーキメープル＆マーガリン
* ポテチ塩

19:50 曳舟の部屋に戻る。勤怠表代わりの子供用携帯電話の充電をしてから PC の電源を入れる。
帳簿をつけてこれを書いてようやく晩飯にありつける。

風呂の時間まで Twitter を見たり（通信量は大丈夫か？）して時間をつぶす。

22:35 風呂から出る。VS Code のドキュメントを適当に見る。

23:30 就寝予定。もう眠い。BGM の最後は偶然にもまたドラクエ 2 だ。

## 『C++ のエッセンス』読書ノート

Bjarne Stroustrup 著、柴田望洋訳『C++ のエッセンス』（2015 年、SB クリエイティブ株式会社）
第 13 章 並行処理より。

### 13.1 はじめに

* 〈標準ライブラリの基本的な目標は、システムレベルの並行処理のサポートであって、洗練された高レベルの並行モデルを直接提供することではない〉
* 標準ライブラリは単一アドレス空間における複数スレッドの並行実行をサポートする。
  * 適切なメモリモデル
  * 一連のアトミック処理
* 〈タスクが逐次的に実行できるのであれば、それが単純で高速になるものだ〉

### 13.2 タスクと `thread`

* **タスク**とは他の処理と並行的に実行される可能性のある処理のことを言う。
* **スレッド**とは一つのプログラムにおけるシステムレベルのタスクを意味する。

複数のタスクを並行的に実行するには、タスクそれぞれから `std::thread` を生成することで行うことができる。
pp. 150-151 のコード片参照。

* スレッド群は同一のアドレス空間を共有する。cf. プロセス
  * そのためスレッド間通信が共有オブジェクトを介することで行える。ただし、データ競合を防ぐことを考えなければならない。
    ロックやその他のメカニズムにより何らかの同期処理を施すのがふつうだ。

* タスクを定義する目的は、タスク同士を完全に分離することだ。
* 共有データを一切使用しないことは、データ競合を起こさないことを意味する。

### 13.3 引数の受渡し

* タスクの入力は関数の実引数という形式でなされるのが自然だが、複数のタスクで同一のデータを参照すると困ったことになるだろう。
  他方、値渡しでは困ったことにはならない。
* 〈`<functional>` が定義する型関数 `ref()` は、可変個引数テンプレートが `some_vec`
  をオブジェクトではなく参照として扱えるようにするために、不本意ながら必要となるものである〉

### 13.4 結果の返却

* 〈やや姑息なのだが、結果の返却手段として引数が使われることは、珍しくない〉。
  すなわち、タスクを表す関数の引数の一部がポインターや非 `const` 参照などで定義されている。
* 〈引数経由で結果を返す方法が特にエレガントであるとは私は思わない〉。まったく同感だ。

### 13.5 データの共有

複数のタスクが同一のデータを共有しなければならないとき、それへアクセスするタスクを高々一つに制限する必要がある。
そのための手段の一つに相互排他オブジェクト mutex を使える。

* `std::mutex` 型のオブジェクトをより広い？スコープに定義する。これを `m` とする。
* 「制限区間」をスコープにして `std::unique_lock<mutex> lck{m};` として RAII する。
  この RAII オブジェクトの役割は直観的に理解できる。
* つまり、プログラマーは `mutex` オブジェクトと共有データを対応付けることになる。その管理に注意しろ。

デッドロックを回避するための技法を p. 154 で例示している。遅延ロックとでも呼べるような技法があるようだ。
これによると、どこかで関数 `lock()` が提供されていて、おそらく可変個の RAII オブジェクトを引き渡すことができる。
その結果、指定されたすべての相互排他オブジェクトのロックを獲得する。

* 共有データによる通信はきわめて低レベル。複数タスクのどれが完了しているのかを判断するのが厳しいから。
* ロック・アンロックはどちらかというと高コストな処理だ。
* 〈通信手段として、データ共有を選択しないようにしよう〉

### 13.6 イベント待ち

スレッドは何らかの外部イベントの完了を待たねばならないことがある。

* `std::this_thread` は唯一のスレッドを表す。
* 外部イベントによる通信機能は `<conditional_variable>` が定義する
  `std::conditional_variable` で提供される。この概念は Python のそれと同等だと考えていいだろう。

  * 〈`conditional_variable` を使うと、エレガントで効率のよい数多くの共有法が実現できるものの、
    若干トリッキーなものとなる〉

古典的な生産者・消費者のデモコード。これも Python で書くとこういう感じになるだろう。
ただし `consumer()` の `lck.unlock()` の呼び出しに注意。キューの中身を取り出した直後に解放して、
それから中身を処理するという構造をよく覚えておくこと。

* `mcond.wait()` をするのは消費者で `mcond.notify_one()` をするのは生産者。
  * 消費者側のロック区間では `mcond.wait()` とキューからメッセージを取り出す。
  * 生産者側のロック区間ではキューへメッセージを置くことと `mcond.notify_one()` を呼び出す。

### 13.7 タスク間通信

`<future>` で定義されている三つのタスク処理機能を説明している。

* `future` と `promise`
* `packaged_task`
* `async()`

#### 13.7.1 `future` と `promise`

* ロックを明示的に使わずに、タスク間で値を転送できるようにするのが重要だ。
* 送信側のタスクが受信側のタスクに値を転送するときには、それを `promise` の中に入れる。
  処理系がそれを対応する `future` に置くので、受信者はそれを読み取れるという構造だ。

  * `future` の `get()` で値を取る。
  * 〈値がまだ置かれていなければ、そのスレッドは、値が到着するまでブロックされる〉。なるほど。
  * `promise` には `set_value()` と `set_exception()` が提供されている。
  * 送信側タスクのコードは p.157 の関数 `f()` の構造を一般的にとるものと思われる。
    受信側タスクは関数 `g()` の構造になる。例外処理を必要としなければ、`try` ブロックはないだろう。

#### 13.7.2 `packaged_task`

型 `packaged_task` は複数の `promise` と `future` を連携する複数タスクの準備に利用する。
p. 158 のコードによると

* `std::packaged_task` オブジェクトをタスクを表す関数から生成する。タスクの個数ぶん生成する。
* `std::future` オブジェクトをスレッド開始前に生成する。それは `std::packaged_task::get_future()` そのものだ。
* `std::thread` のタスクを表す引数に `std::packaged_task` オブジェクトを `std::move()` して渡す。
* 結果をさきほど `.get_future()` から生成しておいたオブジェクトから `.get()` する。
* このコードが明示的なロックを含まないことに注意する。

〈なお、`move()` 処理が必要となっているのは、`packaged_task` がコピーできないからだ。
`packaged_task` がコピーできないのは、それが資源ハンドルだからである〉

#### 13.7.3 `async()`

* 〈非同期に実行される可能性があるタスクの起動には、`async()` が利用できる〉
* 〈`async()` を使うとスレッドやロックの考慮が不要となる〉が、むしろ
  〈ロックが必要な資源を共有するタスクに対しては `async()` を使ってはいけない〉。
* 〈`async()` では `thread` がいくつ起動されるかが分からない〉

### 13.8 アドバイス

いくつか抜粋する。

> * (3) 可能な限り、高い抽象化レベルで作業しよう。
> * (10) 逐次実行のほうが、並行実行よりも簡潔かつ高速な場合もある。
> * (11) データ競合を避けよう。
> * (14) 可能であれば、明示的なデータ共有は避けよう。
> * (20) `thread` と `mutex` を直接利用するのではなく、`packaged_task` と `future`
>   を優先しよう。
> * (24) 単純なタスクの起動には、`async()` を利用しよう。

## メモリ調査ノート

CPU-Z のテキスト保存結果より抜粋。

```console
bash$ sed -n '/^Memory SPD/,/^Monitoring/p; /^Monitoring/q' CPU-Z-report.txt | expand
```

文字列 `Monitoring` から始まる末尾の行を手動で削りこの原稿にペーストすると：

```text
Memory SPD
-------------------------------------------------------------------------

DIMM #                          1
        SMBus address           0x52
        Memory type             DDR3L
        Module format           SO-DIMM
        Module Manufacturer(ID) Samsung (CE000000000000000000000000)
        Size                    4096 MBytes
        Max bandwidth           PC3-12800 (800 MHz)
        Part number             M471B5173QH0-YK0
        Serial number           939B45F2
        Manufacturing date      Week 27/Year 14
        Number of banks         8
        Nominal Voltage         1.35 Volts
        EPP                     no
        XMP                     no
        AMP                     no
JEDEC timings table             CL-tRCD-tRP-tRAS-tRC @ frequency
        JEDEC #1                5.0-5-5-14-19 @ 380 MHz
        JEDEC #2                6.0-6-6-16-22 @ 457 MHz
        JEDEC #3                7.0-7-7-19-26 @ 533 MHz
        JEDEC #4                8.0-8-8-22-30 @ 609 MHz
        JEDEC #5                9.0-9-9-24-33 @ 685 MHz
        JEDEC #6                10.0-10-10-27-37 @ 761 MHz
        JEDEC #7                11.0-11-11-28-39 @ 800 MHz

DIMM #                          1
SPD registers
                00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
        00      92 13 0B 03 04 21 02 01 03 11 01 08 0A 00 FE 00
        10      69 78 69 30 69 11 18 81 20 08 3C 3C 00 F0 83 01
        20      00 00 00 00 00 00 00 00 00 86 00 00 00 00 00 00
        30      00 00 00 00 00 00 00 00 00 00 00 00 2F 11 41 00
        40      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
        50      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
        60      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
        70      00 00 00 00 00 80 CE 02 14 27 93 9B 45 F2 14 8F
        80      4D 34 37 31 42 35 31 37 33 51 48 30 2D 59 4B 30
        90      20 20 00 00 80 CE 00 00 00 55 30 59 48 30 30 30
        A0      01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
        B0      00 00 00 00 00 00 00 00 00 00 00 00 00 30 34 00
        C0      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
        D0      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
        E0      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
        F0      00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
```
