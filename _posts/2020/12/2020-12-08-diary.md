---
title: 226 日目（晴れのち曇り）雑巾がけに力は要らない
---

6:35 起床。洗濯＆朝食。動き出す時間が早すぎたので洗濯物を干しても余裕がある。

7:30 出発。隣町へ移動。現場に到着。鍵を開けて管理人室に入って準備。
まずは燃えるゴミを外へ出す作業だ。中 3 日で 30 袋くらいある。
外へ出すだけではなく、混入しているビンやらペットボトルやらを取り出す作業も含む。
中には麦茶のガラス容器が入っていたりして、なかなか手ごわい。

残り時間で上層階付近で常識的な清掃を行う。壁のカビを取るのに難儀する。

10:00 作業終了。管理会社に電話連絡をして退勤。
拭き掃除で体を動かしまくったせいで喉が渇き切っている。持参した水を飲み干して退散。

イトーヨーカドーに立ち寄ってトイレ。それから曳舟の部屋に戻る。
仕事道具を置いて PC をカバンに詰めて再び外出。コンビニに寄って雑誌チェック。
明治通りのバス停から出発。

11:25 ゆいの森あらかわ入館。四階へ。平日にしては混んでいる。
いつものような作業をするわけだが、時間感覚がおかしい。かなり延長してしまう。
朝刊（東京）を読んで退館。曇り空になっている。バス停に戻る。3 分で亀戸駅行きが来た。

14:45 曳舟の部屋に戻る。おやつ休憩の間に Windows Update を進める。今回は早い。
残りのポテチを食いながら麻雀の練習かな。

16:20 外出。押上駅バスターミナルに移動して錦糸町駅行きに乗る。太平四丁目で降りてオリナスに行く。

タイトー F ステーションオリナス錦糸町店。
ビートマニア STEP UP が不出来。レベル 10 の電人イェーガーのクリア率の低さに驚く。
そして実際にプレイしてみてもっと驚く。当時の私はこんな譜面でよくクリアランプを点灯させたものだ。

MJ プロ卓東風戦に 7 クレぶっこむ。昨日と反対にツキが微妙に悪い。

```text
【SCORE】
合計SCORE:-79.1

【最終段位】
四人打ち段位:雷神 幻球:9

【12/8の最新8試合の履歴】
1st|-----**-
2nd|*---*---
3rd|-*-*----
4th|--*----*
old         new

【順位】
1位回数:2(14.29%)
2位回数:3(21.43%)
3位回数:6(42.86%)
4位回数:3(21.43%)
平均順位:2.71

プレイ局数:66局

【打ち筋】
アガリ率:24.24%(16/66)
平均アガリ翻:2.94翻
平均アガリ巡目:11.56巡
振込み率:6.06%(4/66)

【12/8の最高役】
最高役のデータがありません。最高役は、跳満以上のアガリが対象となります。
```

20:30 カスミオリナス錦糸町店。295 円。

* ライス
* 八宝菜丼

携帯電話のバッテリー残量が妙に少ない。この時間帯で 65 パーというのは記憶にない。

20:50 ビッグエー墨田業平店。708 円。間違って買い過ぎた。白飯はさっき買ったのにもう忘れている。
棚におにぎりがないショックで忘れたのだろうか。

* シュークリーム
* 小粒納豆 (3)
* 下町風の明太クリーム
* ふっくらおむすび梅
* 大きなコロッケバーガー
* クリームパン
* 快適ガードマスクレギュラー (7)

21:00 曳舟の部屋に戻る。即入浴。21:30 出る。PC を開けてレシートの整理。
麻雀の練習をしながら晩飯。それにしても今日は私が振り込むと裏がよく乗る日だ。

23:30 猛烈に眠い。

## 『C++ のエッセンス』読書ノート

Bjarne Stroustrup 著、柴田望洋訳『C++ のエッセンス』（2015 年、SB クリエイティブ株式会社）
第 12 章 数値演算より。

### 12.1 はじめに

〈より複雑なデータ処理では、C++ の強力な機能が真価を発揮する〉

### 12.2 数学関数

* ヘッダーファイル `<cmath>` に標準数学関数と呼ばれる関数がある。
  表によると絶対値、数値を丸める関数、平方根、三角関数、逆三角関数、双曲線関数、逆双曲線関数、指数関数、対数関数が勢ぞろいだ。
* 引数型として次の組み込み型がサポートされている。

  * `float`
  * `double`
  * `long double`

* 〈エラーは、 `<cerrono>` が定義する `errono` への代入によって通知される。
  定義域エラーならば `EDOM` であり、値域エラーならば `ERANGE` である〉。これは知らなかった。
  大域変数を見に行く必要があるとは。

### 12.3 数値アルゴリズム

ヘッダーファイル `<numeric>` は汎用の数値アルゴリズムを提供している。

* `std::accumulate()`: 和
* `std::inner_product()`: スカラー積
* `std::partial_sum()`: 部分和
* `std::adjacent_difference()`: 階差数列
* `std::iota()`: Python の `range()` のようなもの

〈シーケンスの要素に対して演算をパラメータ化して適用することも可能だ〉。

### 12.4 複素数

ヘッダーファイル `<complex>` について。

* クラステンプレート `std::complex` の実部と虚部がテンプレートになっているので、
  `float` でも `double` でもサポートされる。
* また、複素数に対する一般的な算術演算および数学関数も提供されている。

### 12.5 乱数

乱数機能は C++11 で変貌を遂げたようだ。

> 標準ライブラリの `<random>` では、多様な乱数生成関数が提供されている。乱数生成関数は、
> 以下の二つの要素で構成されている：
>
> (1) **エンジン**：乱数または疑似乱数を生成する。  
> (2) **分布**：生成した値を一定範囲の数学的分布へとマップする。

まず p. 144 のコードを見ると、もうわけがわからない。しかし急所を書き換えてくれてある：

```c++
auto die = std::bind(
    std::uniform_int_distribution<>{1, 6},
    std::default_random_engine{});
```

こうすることで呼び出し `die()` が 1 から 6 までの出目を無作為抽出するようになる。

〈初心者にとっては、乱数生成ライブラリのインタフェースが完全に汎用化されていることが、
大きな障害となり得る。そのため、単純な一様乱数の生成から始めるとよいだろう〉

### 12.6 ベクタの算術演算

* `std::vector` には算術演算がサポートされていない。
* 〈標準ライブラリ `<valarray>` で `vector` に似たテンプレート `valarray` を提供している。
  これは汎用性を低めることによって、数値演算を最適化しやすくするものだ〉

### 12.7 数値の限界値

ヘッダーファイル `<limits>` には組み込み型の性質を表すクラスが提供されていて、
p. 146 のコード片のようなコンパイル時診断を可能とする。

### 12.8 アドバイス

いくつか抜粋する。

> (2) 数値演算は技巧的なものとなりがちだ。  
> (3) 言語機能だけで重要な数値演算を行おうとしないように。  
> (6) 乱数生成器を得るには、乱数エンジンに分布をバインドしよう。  
> (9) 数値型の性質は、`numeric_limits` から得られる。  

----

以上

----

第 11 章 ユーティリティもやっておくか？

### 11.1 はじめに

〈小規模だが幅広く有用な〉標準コンポーネントを見ていく。

### 11.2 資源管理

* 本書では資源を次のように定義している：
  〈利用するために獲得して、利用後に暗黙的あるいは明示的に解放するもの〉。
* 〈標準ライブラリのコンポーネントは、資源リークを発生させないように設計されている。
  （略）
  コンストラクタとデストラクタを組み合わせることで、オブジェクトが消滅した際に、
  資源だけが残らないことが保証される〉。この技法が資源管理の基本だとある。

#### 11.2.1 `unique_ptr` と `shared_ptr`

ヘッダーファイル `<memory>` が提供する二種類のスマートポインター：

* `std::unique_ptr`: 所有権が独占的
* `std::shared_ptr`: 所有権が共有される

関数 `std::make_shared()` は存在するが `std::make_unique()` は（本書執筆時点では）存在しない。
ということで、後者の実装例を紹介している。この可変個引数テンプレートと転送参照のコードは重要なので頭に焼き付けておくこと。

〈関数からオブジェクトの集合を返す際に、必ずしもポインタを使う必要はない。
資源ハンドルであるコンテナを使えば、簡潔かつ効率的に行える〉

### 11.3 特殊化されたコンテナ

STL の定めるコンテナ要件と完全に合致しないようなコンテナがいくつかある。
著者はこれを妥当性には欠けるものの almost container と呼んでいる。

* 組み込み配列
* `std::array<T, N>`
* `std::bitset<N>`
* `std::vector<bool>`
* `std::pair<T, U>`
* `std::tuple<T...>`
* `std::basic_string<C>`
* `std::valarray<T>`

#### 11.3.1 `array`

* 〈`array` は、要素数が固定されて、想定外にポインタ型への変換が行われることがなくて、
  僅かではあるものの有用な関数を提供する組み込み配列とみなすとわかりやすい。
  組み込み配列と比較して（時間的あるいは空間的な）オーバーヘッドもない〉
* 〈私が `array` を採用する主な理由は、想定外にポインタへと変換されて困ってしまう
  事態を避けるためだ〉

#### 11.3.2 `bitset`

C++03 と変わらないようなのでノート略。

#### 11.3.3 `pair` と `tuple`

前者は C++03 と変わらないようなのでノート略。

* `std::tuple` は異種要素のシーケンスだと言っているので Python でいう `tuple` と同格の存在だろう。
* 関数 `std::make_tuple()` でオブジェクトを生成するといい。
* 要素を取り出すのに例えば `get<1>(t)` のような〈見苦しい記述〉をする。

### 11.4 時間

〈時間を処理する標準ライブラリ機能は `<chrono>` で、`std::chrono` 部分名前空間の中で定義されている〉

### 11.5 関数アダプタ

* 関数アダプタを次のように説明している：
  〈関数を引数として受け取って、その関数を実行する関数オブジェクトを返す〉。
  つまり機能としては関数だ。
* カレー化、部分評価と呼ばれるものだ。
*〈バインダは過去に多用されていたが、それらの大部分の用途では、ラムダ式を用いることで、
  より容易に記述できると考えられる〉。そうなのか。

#### 11.5.1 `bind()`

* `using namespace placeholders;`
* 〈多重定義した関数の引数をバインドするには、バインド対象がどの関数であるのかを明示する必要がある〉。
  このコード片だと旧式キャストを適用することになる。
* `bind()` の結果を保持するならば `auto` として宣言した変数に対して代入するのがよい。

#### 11.5.2 `mem_fn()`

* `std::mem_fn(mf)` の形でフリー関数として呼び出される関数オブジェクトを生成する。
* 標準アルゴリズムがフリー関数の呼び出しを前提としているので、こういうものが提供される。
* 〈バインダの代わりに、簡潔で汎用的なラムダ式が利用できることも多い〉

```c++
std::for_each(v.begin(), v.end(), std::mem_fn(&Shape::draw));
std::for_each(v.begin(), v.end(), [](Shape* p){ p->draw(); });
```

#### 11.5.3 `function`

```c++
std::function<int(double)> f = std::round;
```

* 〈標準ライブラリの `function` は、呼出し演算子 `()` によって呼び出せる任意のオブジェクトを保持する型だ。
  すなわち、`function` 型のオブジェクトは、関数オブジェクトである〉
* コールバックや処理を引数に渡す場合に有用。

### 11.6 型関数

型関数とは関数であって、次の条件を満たすものを指す：

* 引数か返却値として型が与えられるもの
* コンパイル時に評価されるもの

#### 11.6.1 `iterator_traits`

タグディスパッチの解説。時間がないので略。

#### 11.6.2 型述語

ヘッダーファイル `<type_traits>` に、型に関する基本的な情報を返すだけの単純な型関数が提供されている。
これらの機能はテンプレートを作成する際に有用となる。

* `is_class`, `is_pod`, `is_literal_type`
* `has_trivial_destructor`
* `is_base_of`
* etc.

### 11.7 アドバイス

いくつか抜粋する。

> (3) 取得して解放するものは、すべて資源である  
> (4) 資源管理には、資源ハンドルを使おう (RAII)  
> (8) `shared_ptr` よりも `unique_ptr` を優先しよう  
> (17) しばしば、ラムダは `bind()` や `mem_fn()` の代替となる  

以上
